# frozen_string_literal: true

#
# Vagrantfile
#
# Copyright 2020, Steve Kukla, All Rights Reserved.
require 'json'
require_relative 'lib/main_app'
app = App.new

system('clear')

app.check_for_plugins
app.check_for_authentication
app.check_for_structure
app.check_for_build_action
app.check_for_data_pack_errors
app.check_for_backup_errors

Vagrant.configure('2') do |config|
  # SSH, Box, and URLs
  config.ssh.insert_key = false
  config.ssh.forward_agent = true
  config.vm.box = app.settings['remote_machine']['box']
  config.vm.define app.settings['remote_machine']['name'] do |machine|
    machine.vm.network 'private_network', ip: app.settings['vm']['ip']
    machine.vm.hostname = app.define_urls[:hostname]
  end
  config.hostsupdater.aliases = app.define_urls[:demo_urls]

  # Configure VM machine based on hypervisor
  config.vm.provider app.settings['vm']['hypervisor'] do |machine|
    machine.gui = app.settings['hypervisor']['all']['gui']
    machine.linked_clone = app.settings['hypervisor']['all']['linked_clones']

    if app.settings['vm']['hypervisor'] == 'virtualbox'
      machine.default_nic_type = app.settings['hypervisor']['virtualbox']['default_nic_type']
      machine.customize [
        'modifyvm', :id,
        '--name', app.settings['vm']['name'],
        '--memory', app.settings['remote_machine']['memory'],
        '--cpus', app.settings['remote_machine']['cpus'],
        '--vram', app.settings['remote_machine']['vram'],
        '--vrde', app.settings['hypervisor']['virtualbox']['remote_display']

      ]
    # VMWare-specific settings
    elsif app.settings['vm']['hypervisor'].include?('vmware')
      machine.vmx['memsize'] = app.settings['remote_machine']['memory']
      machine.vmx['numvcpus'] = app.settings['remote_machine']['cpus']
      machine.vmx['ethernet0.pcislotnumber'] = app.settings['hypervisor']['vmware']['eth0_pcislotnumber']
      machine.vmx['ethernet1.pcislotnumber'] = app.settings['hypervisor']['vmware']['eth1_pcislotnumber']
    end
  end

  # Copy selected data packs
  if !app.entries[:user_data_packs].empty? &&
     !app.settings['custom_demo']['data_packs'].empty? &&
     !app.settings['custom_demo']['data_packs'].find { |_key, value| !value['repository_url'].include?('github') }.nil?
    config.trigger.before %i[up reload provision] do |trigger|
      trigger.name = 'Copying local data packs to VM'
      trigger.ruby do
        app.copy_data_packs
      end
    end
  end

  # Copy patches
  unless app.entries[:user_patches].empty?
    config.trigger.before [:up, :reload, :provision] do |trigger|
      trigger.name = 'Copying patches to the VM'
      trigger.ruby do
        app.copy_patches
      end
    end
  end

  # Handle backups
  if app.settings['application']['build']['action'] == 'restore' &&
     !app.entries[:user_backups].empty? &&
     ['.zip', '.tgz', '.sql'].any? { |type| app.entries[:user_backups].find { |file| file.include?(type) } }
    config.trigger.before %i[up provision] do |trigger|
      trigger.name = 'Copying local backup files'
      trigger.ruby do
        app.copy_local_backup_files
      end
    end
  end

  # Write out chef environment file from configuration
  config.trigger.before %i[up reload provision] do |trigger|
    trigger.name = 'Creating environment file'
    trigger.ruby do
      app.create_environment_file
    end
  end

  # Run Chef provisioner
  config.vm.provision app.settings['provisioner']['type'] do |chef|
    chef.version = app.settings['provisioner']['version'].chomp
    chef.nodes_path = (app.settings['provisioner']['nodes_path'])
    chef.environments_path = (app.settings['provisioner']['environments_path'])
    chef.roles_path = (app.settings['provisioner']['roles_path'])
    chef.cookbooks_path = (app.settings['provisioner']['cookbooks_path'])
    chef.environment = 'vm'
    chef.add_role 'base'
    chef.add_role 'infrastructure'
    chef.add_role 'application'
    chef.arguments = '--chef-license accept'
  end

  # Post-build clean-up
  config.trigger.after %i[up provision] do |trigger|
    trigger.name = 'Cleaning up application cache'
    trigger.ruby do
      app.clean_up_chef_cache
    end
  end

  # SSL certificates triggers
  config.trigger.after :destroy do |trigger|
    trigger.name = 'Cleaning up ssl certificate'
    trigger.ruby do
      app.remove_all_keychain_ssl_certificates
      app.remove_all_ssl_certificates
    end
  end

  if app.settings['application'].key?('settings') &&
     (app.settings['application']['settings'].key?('use_secure_frontend') || app.settings['application']['settings'].key?('use_secure_backend')) &&
     (!app.settings['application']['settings']['use_secure_frontend'].nil? || !app.settings['application']['settings']['use_secure_admin'].nil?) &&
     (app.settings['application']['settings']['use_secure_frontend'] == true || app.settings['application']['settings']['use_secure_admin'] == true)

    config.trigger.after %i[up provision] do |trigger|
      trigger.name = 'Setting up ssl certificate'
      trigger.ruby do
        app.remove_old_keychain_ssl_certificates
        app.set_up_ssl_certificates
        app.remove_old_ssl_certificates
      end
    end
  end
end
